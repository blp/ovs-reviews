import OVN_Northbound as nb
import multicast
import ovsdb
import ovn
import helpers
import lswitch

output relation Warning(message: string)

/* LogicalRouterPortCandidate.
 *
 * Each row pairs a logical router port with its logical router, but without
 * checking that the logical router port is on only one logical router.
 *
 * (Use LogicalRouterPort instead, which guarantees uniqueness.) */
relation LogicalRouterPortCandidate(lrp_uuid: uuid, lr_uuid: uuid)
LogicalRouterPortCandidate(lrp_uuid, lr_uuid) :-
    nb.Logical_Router(._uuid = lr_uuid, .ports = ports),
    var lrp_uuid = FlatMap(ports).
Warning(message) :-
    LogicalRouterPortCandidate(lrp_uuid, lr_uuid),
    var lrs = Aggregate((lrp_uuid), group2set(lr_uuid)),
    set_size(lrs) > 64'd1,
    lrp in nb.Logical_Router_Port(._uuid = lrp_uuid),
    var message = "Bad configuration: logical router port ${lrp.name} belongs "
    "to more than one logical router".

/* Each row means 'lport' is in 'lrouter' (and only that lrouter). */
relation LogicalRouterPort(lport: uuid, lrouter: uuid)
LogicalRouterPort(lrp_uuid, lr_uuid) :-
    LogicalRouterPortCandidate(lrp_uuid, lr_uuid),
    var lrs = Aggregate((lrp_uuid), group2set(lr_uuid)),
    set_size(lrs) == 64'd1,
    Some{var lr_uuid: uuid} = set_nth(lrs, 0).

/*
 * Peer routers.
 *
 * Each row in the relation indicates that routers 'a' and 'b' can reach
 * each other directly through router ports.
 *
 * This relation is symmetric: if (a,b) then (b,a).
 * This relation is antireflexive: if (a,b) then a != b.
 *
 * Routers aren't peers if they can reach each other only through logical
 * switch ports (that's the ReachableLogicalRouter table).
 */
relation PeerLogicalRouter(a: uuid, b: uuid)
PeerLogicalRouter(lrp_uuid, peer._uuid) :-
  LogicalRouterPort(lrp_uuid, _),
  lrp in nb.Logical_Router_Port(._uuid = lrp_uuid),
  var peer_name = FlatMap(lrp.peer),
  peer in nb.Logical_Router_Port(.name = peer_name),
  peer.peer == set_singleton(lrp.name), // 'peer' must point back to 'lrp'
  lrp_uuid != peer._uuid.		        // No reflexive pointers.

/*
 * First-hop routers.
 *
 * Each row indicates that 'lrouter' is a first-hop logical router for
 * 'lswitch', that is, that a "cable" directly connects 'lrouter' and
 * 'lswitch'.
 *
 * A switch can have multiple first-hop routers. */
relation FirstHopLogicalRouter(lrouter: uuid, lswitch: uuid)
FirstHopLogicalRouter(lrouter, lswitch) :-
  LogicalRouterPort(lrp_uuid, lrouter),
  lrp in nb.Logical_Router_Port(._uuid = lrp_uuid),
  LogicalSwitchPort(lsp_uuid, lswitch),
  lsp in nb.Logical_Switch_Port(._uuid = lsp_uuid),
  lsp.__type == "router",
  map_get(lsp.options, "router-port") == Some{lrp.name},
  set_is_empty(lrp.peer).

/*
 * Reachable routers.
 *
 * Each row in the relation indicates that routers 'a' and 'b' can reach each
 * other directly or indirectly through any chain of logical routers and
 * switches.
 *
 * This relation is symmetric: if (a,b) then (b,a).
 * This relation is reflexive: (a,a) is always true.
 */
relation ReachableLogicalRouter(a: uuid, b: uuid)
ReachableLogicalRouter(a, b) :-
    PeerLogicalRouter(a, c),
    ReachableLogicalRouter(c, b).
ReachableLogicalRouter(a, b) :-
    FirstHopLogicalRouter(a, ls),
    FirstHopLogicalRouter(b, ls).
ReachableLogicalRouter(a, a) :- ReachableLogicalRouter(a, _).

// ha_chassis_group and gateway_chassis may not both be present.
Warning(message) :-
    lrp in nb.Logical_Router_Port(),
    not set_is_empty(lrp.ha_chassis_group),
    not set_is_empty(lrp.gateway_chassis),
    var message = "Both ha_chassis_group and gateway_chassis configured on "
    "port ${lrp.name}; ignoring the latter".

// A distributed gateway port cannot also be an L3 gateway router.
Warning(message) :-
    lrp in nb.Logical_Router_Port(),
    not set_is_empty(lrp.ha_chassis_group)
        or not set_is_empty(lrp.gateway_chassis),
    map_contains_key(lrp.options, "chassis"),
    var message = "Bad configuration: distributed gateway port configured on "
    "port ${lrp.name} on L3 gateway router".

/* DistributedGatewayPortCandidate.
 *
 * Each row pairs a logical router with its distributed gateway port,
 * but without checking that there is at most one DGP per LR.
 *
 * (Use DistributedGatewayPort instead, since it guarantees uniqueness.) */
relation DistributedGatewayPortCandidate(lr_uuid: uuid, lrp_uuid: uuid)
DistributedGatewayPortCandidate(lr_uuid, lrp_uuid) :-
    lr in nb.Logical_Router(._uuid = lr_uuid),
    LogicalRouterPort(lrp_uuid, lr._uuid),
    lrp in nb.Logical_Router_Port(._uuid = lrp_uuid),
    not map_contains_key(lrp.options, "chassis"),
    var has_hcg = not set_is_empty(lrp.ha_chassis_group),
    var has_gc = not set_is_empty(lrp.gateway_chassis),
    has_hcg or has_gc,
    not has_hcg or not has_gc.
Warning(message) :-
    DistributedGatewayPortCandidate(lr_uuid, lrp_uuid),
    var lrps = Aggregate((lr_uuid), group2set(lrp_uuid)),
    set_size(lrps) > 64'd1,
    lr in nb.Logical_Router(._uuid = lr_uuid),
    var message = "Bad configuration: multiple distributed gateway ports on "
    "logical router ${lr.name}".

/* Distributed gateway ports.
 *
 * Each row means 'lrp' is the distributed gateway port on 'lr_uuid'.
 *
 * There is at most one distributed gateway port per logical router. */
relation DistributedGatewayPort(lrp: nb.Logical_Router_Port, lr_uuid: uuid)
DistributedGatewayPort(lrp, lr_uuid) :-
    DistributedGatewayPortCandidate(lr_uuid, lrp_uuid),
    var lrps = Aggregate((lr_uuid), group2set(lrp_uuid)),
    set_size(lrps) == 64'd1,
    Some{var lrp_uuid} = set_nth(lrps, 0),
    lrp in nb.Logical_Router_Port(._uuid = lrp_uuid).

/* HAChassis is an abstraction over nb.Gateway_Chassis and nb.HA_Chassis, which
 * are different ways to represent the same configuration.  Each row is
 * effectively one HA_Chassis record for logical router 'lr_uuid'.
 *
 * nb.Gateway_Chassis has an "options" column that this omits because
 * nb.HA_Chassis doesn't have anything similar.  That's OK because no options
 * were ever defined. */
relation HAChassis(lr_uuid: uuid,
                   chassis_name: string,
                   priority: integer,
                   external_ids: Map<string,string>)
HAChassis(lr_uuid, chassis_name, priority, external_ids) :-
    DistributedGatewayPort(lrp, lr_uuid),
    var gw_chassis_uuid = FlatMap(lrp.gateway_chassis),
    nb.Gateway_Chassis(._uuid = gw_chassis_uuid,
                       .chassis_name = chassis_name,
                       .priority = priority,
                       .external_ids = external_ids).
HAChassis(lr_uuid, chassis_name, priority, external_ids) :-
    DistributedGatewayPort(lrp, lr_uuid),
    var ha_chassis_group_uuid = FlatMap(lrp.ha_chassis_group),
    ha_chassis_group in nb.HA_Chassis_Group(._uuid = ha_chassis_group_uuid),
    var ha_chassis_uuid = FlatMap(ha_chassis_group.ha_chassis),
    nb.HA_Chassis(._uuid = ha_chassis_uuid,
                  .chassis_name = chassis_name,
                  .priority = priority,
                  .external_ids = external_ids).

/* HAChassisGroup is an abstraction for sb.HA_Chassis_Group that papers over
 * the two southbound ways to configure it via nb.Gateway_Chassis and
 * nb.HA_Chassis.  The former configuration method does not provide a name or
 * external_ids for the group (only for individual chassis), so we generate
 * them. */
relation HAChassisGroup(lr_uuid: uuid,
                        name: string,
                        external_ids: Map<string,string>)
HAChassisGroup(lr_uuid, name, map_empty()) :-
    DistributedGatewayPort(lrp, lr_uuid),
    var gw_chassis_uuid = FlatMap(lrp.gateway_chassis),
    var name = lrp.name.
HAChassisGroup(lr_uuid, name, external_ids) :-
    DistributedGatewayPort(lrp, lr_uuid),
    var ha_chassis_group_uuid = FlatMap(lrp.ha_chassis_group),
    nb.HA_Chassis_Group(._uuid = ha_chassis_group_uuid,
                        .name = name,
                        .external_ids = external_ids).

/* For each router port, tracks whether it's a redirect port of its router */
relation RouterPortIsRedirect(lrp: uuid, is_redirect: bool)
RouterPortIsRedirect(lrp, true) :- DistributedGatewayPort(nb.Logical_Router_Port{._uuid = lrp}, _).
RouterPortIsRedirect(lrp, false) :-
    nb.Logical_Router_Port(._uuid = lrp),
    not DistributedGatewayPort(nb.Logical_Router_Port{._uuid = lrp}, _).

relation LogicalRouterRedirectPort(lr: uuid, has_redirect_port: Option<nb.Logical_Router_Port>)

LogicalRouterRedirectPort(lr, Some{lrp}) :-
    DistributedGatewayPort(lrp, lr).

LogicalRouterRedirectPort(lr, None) :-
    nb.Logical_Router(._uuid = lr),
    not DistributedGatewayPort(_, lr).

relation LogicalRouterNAT(lr: uuid, nat: Ref<nb.NAT>)

LogicalRouterNAT(lr, nat) :-
    nb.Logical_Router(._uuid = lr, .nat = nats),
    var nat_uuid = FlatMap(nats),
    nat in &NATRef[nb.NAT{._uuid = nat_uuid}].

relation LogicalRouterNATs(lr: uuid, nat: Vec<Ref<nb.NAT>>)

LogicalRouterNATs(lr, nats) :-
     LogicalRouterNAT(lr, nat),
     var nats = Aggregate((lr), group2vec(nat)).

LogicalRouterNATs(lr, vec_empty()) :-
    nb.Logical_Router(._uuid = lr),
    not LogicalRouterNAT(lr, _).

relation LogicalRouterLB(lr: uuid, nat: Ref<nb.Load_Balancer>)

LogicalRouterLB(lr, lb) :-
    nb.Logical_Router(._uuid = lr, .load_balancer = lbs),
    var lb_uuid = FlatMap(lbs),
    lb in &LoadBalancerRef[nb.Load_Balancer{._uuid = lb_uuid}].

relation LogicalRouterLBs(lr: uuid, nat: Vec<Ref<nb.Load_Balancer>>)

LogicalRouterLBs(lr, lbs) :-
     LogicalRouterLB(lr, lb),
     var lbs = Aggregate((lr), group2vec(lb)).

LogicalRouterLBs(lr, vec_empty()) :-
    nb.Logical_Router(._uuid = lr),
    not LogicalRouterLB(lr, _).

/* Router relation collects all attributes of a logical router.
 *
 * `lr` - Logical_Router record from the NB database
 * `l3dgw_port` - optional redirect port (see `DistributedGatewayPort`)
 * `redirect_port_name` - derived redirect port name (or empty string if
 *      router does not have a redirect port)
 * `is_gateway` - true iff the router is a gateway router.  Together with
 *      `l3dgw_port`, this flag affects the generation of various flows
 *      related to NAT and load balancing.
 * `snat_external_ips` - possibly empty set of SNAT external IPs for the router
 */

function chassis_redirect_name(port_name: string): string = "cr-${port_name}"

relation &Router(
    lr:                 nb.Logical_Router,
    l3dgw_port:         Option<nb.Logical_Router_Port>,
    redirect_port_name: string,
    is_gateway:         bool,
    nats:               Vec<Ref<nb.NAT>>,
    lbs:                Vec<Ref<nb.Load_Balancer>>,
    mcast_cfg:          Ref<McastRouterCfg>
)

&Router(.lr = lr,
        .l3dgw_port = l3dgw_port,
        .redirect_port_name =
            match (l3dgw_port) {
                Some{rport} -> json_string_escape(chassis_redirect_name(rport.name)),
                _ -> ""
            },
        .is_gateway = is_some(map_get(lr.options, "chassis")),
        .nats       = nats,
        .lbs        = lbs,
        .mcast_cfg  = mcast_cfg) :-
    lr in nb.Logical_Router(),
    is_enabled(lr.enabled),
    LogicalRouterRedirectPort(lr._uuid, l3dgw_port),
    LogicalRouterNATs(lr._uuid, nats),
    LogicalRouterLBs(lr._uuid, lbs),
    mcast_cfg in &McastRouterCfg(.datapath = lr._uuid).

/* RouterLB: many-to-many relation between logical routers and nb.LB */
relation RouterLB(router: Ref<Router>, lb: Ref<nb.Load_Balancer>)

RouterLB(router, lb) :-
    router in &Router(.lbs = lbs),
    var lb = FlatMap(lbs).

/* Load balancer VIPs associated with routers */
relation RouterLBVIP(
    router: Ref<Router>,
    lb: Ref<nb.Load_Balancer>,
    vip: string,
    backends: string)

RouterLBVIP(router, lb, vip, backends) :-
    RouterLB(router, lb@(&nb.Load_Balancer{.vips = vips})),
    var kv = FlatMap(vips),
    (var vip, var backends) = kv.

/* Router-to-router logical port connections */
relation RouterRouterPeer(rport1: uuid, rport2: uuid, rport2_name: string)

RouterRouterPeer(rport1, rport2, peer_name) :-
    nb.Logical_Router_Port(._uuid = rport1, .peer = peer),
    Some{var peer_name} = set_nth(peer, 0),
    nb.Logical_Router_Port(._uuid = rport2, .name = peer_name).

/* Router port can peer with anothe router port, a switch port or have
 * no peer.
 */
typedef RouterPeer = PeerRouter{rport: uuid, name: string}
                   | PeerSwitch{sport: uuid, name: string}
                   | PeerNone

function router_peer_name(peer: RouterPeer): Option<string> = {
    match (peer) {
        PeerRouter{_, n} -> Some{n},
        PeerSwitch{_, n} -> Some{n},
        PeerNone         -> None
    }
}

relation RouterPortPeer(rport: uuid, peer: RouterPeer)

/* Router-to-router logical port connections */
RouterPortPeer(rport, PeerSwitch{sport, sport_name}) :-
    SwitchRouterPeer(sport, sport_name, rport).

RouterPortPeer(rport1, PeerRouter{rport2, rport2_name}) :-
    RouterRouterPeer(rport1, rport2, rport2_name).

RouterPortPeer(rport, PeerNone) :-
    nb.Logical_Router_Port(._uuid = rport),
    not SwitchRouterPeer(_, _, rport),
    not RouterRouterPeer(rport, _, _).

/* FIXME: what should happen when extract_lrp_networks fails? */
/* RouterPort relation collects all attributes of a logical router port */
relation &RouterPort(
    lrp:              nb.Logical_Router_Port,
    json_name:        string,
    networks:         lport_addresses,
    router:           Ref<Router>,
    is_redirect:      bool,
    peer:             RouterPeer,
    mcast_cfg:        Ref<McastPortCfg>)

&RouterPort(.lrp                = lrp,
            .json_name          = json_string_escape(lrp.name),
            .networks           = networks,
            .router             = router,
            .is_redirect        = is_redirect,
            .peer               = peer,
            .mcast_cfg          = mcast_cfg) :-
    nb.Logical_Router_Port[lrp],
    Some{var networks} = extract_lrp_networks(lrp.mac, lrp.networks),
    LogicalRouterPort(lrp._uuid, lrouter_uuid),
    router in &Router(.lr = nb.Logical_Router{._uuid = lrouter_uuid}),
    RouterPortIsRedirect(lrp._uuid, is_redirect),
    RouterPortPeer(lrp._uuid, peer),
    mcast_cfg in &McastPortCfg(.port = lrp._uuid, .router_port = true).

relation RouterPortNetworksIPv4Addr(port: Ref<RouterPort>, addr: ipv4_netaddr)

RouterPortNetworksIPv4Addr(port, addr) :-
    port in &RouterPort(.networks = networks),
    var addr = FlatMap(networks.ipv4_addrs).

relation RouterPortNetworksIPv6Addr(port: Ref<RouterPort>, addr: ipv6_netaddr)

RouterPortNetworksIPv6Addr(port, addr) :-
    port in &RouterPort(.networks = networks),
    var addr = FlatMap(networks.ipv6_addrs).

/* StaticRoute: Collects and parses attributes of a static route. */
typedef route_policy = SrcIp | DstIp
function route_policy_from_string(s: Option<string>): route_policy = {
    match (s) {
        Some{"src-ip"} -> SrcIp,
        _ -> DstIp
    }
}
function route_policy2string(policy: route_policy): string = {
    match (policy) {
        SrcIp -> "src-ip",
        DstIp -> "dst-ip"
    }
}

typedef route_key = RouteKey {
    policy: route_policy,
    ip_prefix: v46_ip,
    plen: bit<32>
}

relation &StaticRoute(lrsr: nb.Logical_Router_Static_Route,
                      key: route_key,
                      nexthop: v46_ip,
                      output_port: Option<string>)

&StaticRoute(.lrsr        = lrsr,
             .key         = RouteKey{policy, ip_prefix, plen},
             .nexthop     = nexthop,
             .output_port = output_port) :-
    lrsr in nb.Logical_Router_Static_Route(),
    var policy = route_policy_from_string(set_nth(lrsr.policy, 0)),
    Some{(var nexthop, var nexthop_plen)} = ip46_parse_cidr(lrsr.nexthop),
    match (nexthop) {
        IPv4{_} -> nexthop_plen == 32,
        IPv6{_} -> nexthop_plen == 128
    },
    Some{(var ip_prefix, var plen)} = ip46_parse_cidr(lrsr.ip_prefix),
    match ((nexthop, ip_prefix)) {
        (IPv4{_}, IPv4{_}) -> true,
        (IPv6{_}, IPv6{_}) -> true,
        _ -> false
    },
    var output_port = set_nth(lrsr.output_port, 0).

/* Returns the IP address of the router port 'op' that
 * overlaps with 'ip'.  If one is not found, returns None. */
function find_lrp_member_ip(networks: lport_addresses, ip: v46_ip): Option<v46_ip> =
{
    match (ip) {
        IPv4{ip4} -> {
            for (na in networks.ipv4_addrs) {
                if (((na.network ^ ip4) & na.mask) == 0) {
                    /* There should be only 1 interface that matches the
                     * supplied IP.  Otherwise, it's a configuration error,
                     * because subnets of a router's interfaces should NOT
                     * overlap. */
                    return Some{IPv4{na.addr}}
                }
            };
            return None
        },
        IPv6{ip6} -> {
            for (na in networks.ipv6_addrs) {
                var xor_addr = ipv6_addr_bitxor(na.network, ip6);
                var and_addr = ipv6_addr_bitand(xor_addr, na.mask);
                if (ipv6_is_zero(and_addr)) {
                    /* There should be only 1 interface that matches the
                     * supplied IP.  Otherwise, it's a configuration error,
                     * because subnets of a router's interfaces should NOT
                     * overlap. */
                    return Some{IPv6{na.addr}}
                }
            };
            return None
        }
    }
}


/* Step 1: compute router-route pairs */
relation RouterStaticRoute_(
    router      : Ref<Router>,
    key         : route_key,
    nexthop     : v46_ip,
    output_port : Option<string>)

RouterStaticRoute_(.router = router,
                   .key = route.key,
                   .nexthop = route.nexthop,
                   .output_port = route.output_port) :-
    router in &Router(.lr = nb.Logical_Router{.static_routes = routes}),
    var route_id = FlatMap(routes),
    route in &StaticRoute(.lrsr = nb.Logical_Router_Static_Route{._uuid = route_id}).

/* Step-2: compute output_port for each pair */
typedef route_dst = RouteDst {
    nexthop: v46_ip,
    src_ip: v46_ip,
    port: Ref<RouterPort>
}

relation RouterStaticRoute(
    router      : Ref<Router>,
    key         : route_key,
    dsts        : Set<route_dst>)

RouterStaticRoute(router, key, dsts) :-
    RouterStaticRoute_(.router = router,
                       .key = key,
                       .nexthop = nexthop,
                       .output_port = None),
    /* output_port is not specified, find the
     * router port matching the next hop. */
    port in &RouterPort(.router = &Router{.lr = nb.Logical_Router{._uuid = router.lr._uuid}},
                        .networks = networks),
    Some{var src_ip} = find_lrp_member_ip(networks, nexthop),
    var dst = RouteDst{nexthop, src_ip, port},
    var dsts = Aggregate((router, key), group2set(dst)).

RouterStaticRoute(router, key, dsts) :-
    RouterStaticRoute_(.router = router,
                       .key = key,
                       .nexthop = nexthop,
                       .output_port = Some{oport}),
    /* output_port specified */
    port in &RouterPort(.lrp = nb.Logical_Router_Port{.name = oport},
                        .networks = networks),
    Some{var src_ip: v46_ip} = match (find_lrp_member_ip(networks, nexthop)) {
        Some{src_ip} -> Some{src_ip},
        None -> {
            /* There are no IP networks configured on the router's port via
             * which 'route->nexthop' is theoretically reachable.  But since
             * 'out_port' has been specified, we honor it by trying to reach
             * 'route->nexthop' via the first IP address of 'out_port'.
             * (There are cases, e.g in GCE, where each VM gets a /32 IP
             * address and the default gateway is still reachable from it.) */
             match (key.ip_prefix) {
                IPv4{_} -> match (vec_nth(networks.ipv4_addrs, 0)) {
                    Some{addr} -> Some{IPv4{addr.addr}},
                    None       -> {
                        warn("No path for static route ${key.ip_prefix}; next hop ${nexthop}");
                        None
                    }
                },
                IPv6{_} -> match (vec_nth(networks.ipv6_addrs, 0)) {
                    Some{addr} -> Some{IPv6{addr.addr}},
                    None       -> {
                        warn("No path for static route ${key.ip_prefix}; next hop ${nexthop}");
                        None
                    }
                }
            }
        }
    },
    var dsts = set_singleton(RouteDst{nexthop, src_ip, port}).

Warning(message) :-
    RouterStaticRoute_(.router = router, .key = key, .nexthop = nexthop),
    not RouterStaticRoute(.router = router, .key = key),
    var message = "No path for ${key.policy} static route ${key.ip_prefix}/${key.plen} with next hop ${nexthop}".
