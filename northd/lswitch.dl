import OVN_Northbound as nb
import OVN_Southbound as sb
import ovsdb
import ovn
import lrouter
import multicast
import helpers
import ipam

relation SwitchRouterPeerRef(lsp: uuid, rport: Option<Ref<RouterPort>>)

SwitchRouterPeerRef(lsp, Some{rport}) :-
    SwitchRouterPeer(lsp, _, lrp),
    rport in &RouterPort(.lrp = nb.Logical_Router_Port{._uuid = lrp}).

SwitchRouterPeerRef(lsp, None) :-
    nb.Logical_Switch_Port(._uuid = lsp),
    not SwitchRouterPeer(lsp, _, _).

/* map logical ports to logical switches */
relation LogicalSwitchPort(lport: uuid, lswitch: uuid)

LogicalSwitchPort(lport, lswitch) :-
    nb.Logical_Switch(._uuid = lswitch, .ports = ports),
    var lport = FlatMap(ports).

/* Logical switches that have enabled ports with "unknown" address */
relation LogicalSwitchUnknownPorts(ls: uuid, port_ids: Set<uuid>)

LogicalSwitchUnknownPorts(ls_uuid, port_ids) :-
    &SwitchPort(.lsp = lsp, .sw = &Switch{.ls = ls}),
    is_enabled(lsp.enabled) and set_contains(lsp.addresses, "unknown"),
    var ls_uuid = ls._uuid,
    var port_ids = Aggregate((ls_uuid), group2set(lsp._uuid)).

/* PortStaticAddresses: static IP addresses associated with each Logical_Switch_Port */
relation PortStaticAddresses(lsport: uuid, ip4addrs: Set<string>, ip6addrs: Set<string>)

PortStaticAddresses(.lsport     = port_uuid,
                    .ip4addrs   = set_unions(ip4_addrs),
                    .ip6addrs   = set_unions(ip6_addrs)) :-
    nb.Logical_Switch_Port(._uuid = port_uuid, .addresses = addresses),
    var address = FlatMap(if set_is_empty(addresses) set_singleton("") else addresses),
    (var ip4addrs: Set<string>, var ip6addrs: Set<string>) = if (not is_dynamic_lsp_address(address)) {
        split_addresses(address)
    } else { (set_empty(), set_empty()) },
    var static_addrs = Aggregate((port_uuid), group_unzip((ip4addrs, ip6addrs))),
    (var ip4_addrs, var ip6_addrs) = static_addrs.

relation PortInGroup(port: uuid, group: uuid)

PortInGroup(port, group) :-
    nb.Port_Group(._uuid = group, .ports = ports),
    var port = FlatMap(ports).

/* All ACLs associated with logical switch */
relation LogicalSwitchACL(ls: uuid, acl: uuid)

LogicalSwitchACL(ls, acl) :-
    nb.Logical_Switch(._uuid = ls, .acls = acls),
    var acl = FlatMap(acls).

LogicalSwitchACL(ls, acl) :-
    nb.Logical_Switch(._uuid = ls, .ports = ports),
    var port_id = FlatMap(ports),
    PortInGroup(port_id, group_id),
    nb.Port_Group(._uuid = group_id, .acls = acls),
    var acl = FlatMap(acls).

relation LogicalSwitchStatefulACL(ls: uuid, acl: uuid)

LogicalSwitchStatefulACL(ls, acl) :-
    LogicalSwitchACL(ls, acl),
    nb.ACL(._uuid = acl, .action = "allow-related").

relation LogicalSwitchHasStatefulACL(ls: uuid, has_stateful_acl: bool)

LogicalSwitchHasStatefulACL(ls, true) :-
    LogicalSwitchStatefulACL(ls, _).

LogicalSwitchHasStatefulACL(ls, false) :-
    nb.Logical_Switch(._uuid = ls),
    not LogicalSwitchStatefulACL(ls, _).

relation LogicalSwitchLocalnetPort0(ls_uuid: uuid, lsp_name: string)
LogicalSwitchLocalnetPort0(ls_uuid, lsp_name) :-
    ls in nb.Logical_Switch(._uuid = ls_uuid),
    var lsp_uuid = FlatMap(ls.ports),
    lsp in nb.Logical_Switch_Port(._uuid = lsp_uuid),
    lsp.__type == "localnet",
    var lsp_name = lsp.name.

relation LogicalSwitchLocalnetPort(ls_uuid: uuid, lsp: Option<string>)
LogicalSwitchLocalnetPort(ls_uuid, Some{lsp_name}) :-
    LogicalSwitchLocalnetPort0(ls_uuid, lsp_name).
LogicalSwitchLocalnetPort(ls_uuid, None) :-
    ls in nb.Logical_Switch(),
    var ls_uuid = ls._uuid,
    not LogicalSwitchLocalnetPort0(ls_uuid, _).

/* Flatten the list of dns_records in Logical_Switch */
relation LogicalSwitchDNS(ls_uuid: uuid, dns_uuid: uuid)

LogicalSwitchDNS(ls._uuid, dns_uuid) :-
    nb.Logical_Switch[ls],
    var dns_uuid = FlatMap(ls.dns_records),
    nb.DNS(._uuid = dns_uuid).

relation LogicalSwitchWithDNSRecords(ls: uuid)

LogicalSwitchWithDNSRecords(ls) :-
    LogicalSwitchDNS(ls, dns_uuid),
    nb.DNS(._uuid = dns_uuid, .records = records),
    not map_is_empty(records).

relation LogicalSwitchHasDNSRecords(ls: uuid, has_dns_records: bool)

LogicalSwitchHasDNSRecords(ls, true) :-
    LogicalSwitchWithDNSRecords(ls).

LogicalSwitchHasDNSRecords(ls, false) :-
    nb.Logical_Switch(._uuid = ls),
    not LogicalSwitchWithDNSRecords(ls).

/* Switch relation collects all attributes of a logical switch */

relation &Switch(
    ls:                nb.Logical_Switch,
    has_stateful_acl:  bool,
    has_dns_records:   bool,
    has_localnet_port: bool,
    localnet_port_name: Option<string>,
    subnet:            Option<(ovs_be32/*subnet*/, ovs_be32/*mask*/, bit<32>/*start_ipv4*/, bit<32>/*total_ipv4s*/)>,
    ipv6_prefix:       Option<in6_addr>,
    mcast_cfg:         Ref<McastSwitchCfg>
)

function ipv6_parse_prefix(s: string): Option<in6_addr> {
    if (string_contains(s, "/")) {
        match (ipv6_parse_cidr(s)) {
            Right{(addr, 64)} -> Some{addr},
            _ -> None
        }
    } else {
        ipv6_parse(s)
    }
}

&Switch(.ls                = ls,
        .has_stateful_acl  = has_stateful_acl,
        .has_dns_records   = has_dns_records,
        .has_localnet_port = has_localnet_port,
        .localnet_port_name = localnet_port_name,
        .subnet            = subnet,
        .ipv6_prefix       = ipv6_prefix,
        .mcast_cfg         = mcast_cfg) :-
    nb.Logical_Switch[ls],
    LogicalSwitchHasStatefulACL(ls._uuid, has_stateful_acl),
    LogicalSwitchHasDNSRecords(ls._uuid, has_dns_records),
    LogicalSwitchLocalnetPort(ls._uuid, localnet_port_name),
    var has_localnet_port = match (localnet_port_name) {
        Some{_} -> true,
        None -> false
    },
    mcast_cfg in &McastSwitchCfg(.datapath = ls._uuid),
    var subnet: Option<(ovs_be32, ovs_be32, bit<32>, bit<32>)> =
        match (map_get(ls.other_config, "subnet")) {
            None -> None,
            Some{subnet_str} -> {
                match (ip_parse_masked(subnet_str)) {
                    Left{err} -> {
                        warn("bad 'subnet' ${subnet_str}");
                        None
                    },
                    Right{(subnet, mask)} -> {
                        if (mask == oVS_BE32_MAX() or not ip_is_cidr(mask)) {
                            warn("bad 'subnet' ${subnet_str}");
                            None
                        } else {
                            Some{(subnet, mask, ntohl(subnet) + 1, ~ntohl(mask))}
                        }
                    }
                }
            }
        },
    var ipv6_prefix: Option<in6_addr> =
        match (map_get(ls.other_config, "ipv6_prefix")) {
            None -> None,
            Some{prefix} -> ipv6_parse_prefix(prefix)
        }.

/* SwitchLB: many-to-many relation between logical switches and nb.LB */
relation SwitchLB(sw: Ref<Switch>, lb: Ref<nb.Load_Balancer>)

SwitchLB(sw, lb) :-
    sw in &Switch(.ls = nb.Logical_Switch{.load_balancer = lb_ids}),
    var lb_id = FlatMap(lb_ids),
    lb in &LoadBalancerRef[nb.Load_Balancer{._uuid = lb_id}].

/* Load balancer VIPs associated with switch */
relation SwitchLBVIP(sw: Ref<Switch>, lb: Ref<nb.Load_Balancer>, vip: string, backends: string)

SwitchLBVIP(sw, lb, vip, backends) :-
    SwitchLB(sw, lb@(&nb.Load_Balancer{.vips = vips})),
    var kv = FlatMap(vips),
    (var vip, var backends) = kv.

relation SwitchHasLBVIP(sw: Ref<Switch>)
SwitchHasLBVIP(sw) :- SwitchLBVIP(.sw = sw).

relation &LBVIP(
    lb: Ref<nb.Load_Balancer>,
    vip_key: string,
    vip_addr: string,
    vip_port: bit<16>,
    addr_family: bit<32>,
    backend_ips: string)

&LBVIP(.lb = lb,
       .vip_key = vip_key,
       .vip_addr = vip_addr,
       .vip_port = vip_port,
       .addr_family = addr_family,
       .backend_ips = backend_ips) :-
    LoadBalancerRef[lb],
    var vip = FlatMap(lb.vips),
    (var vip_key, var backend_ips) = vip,
    Some{(var vip_addr, var vip_port, var addr_family)} = ip_address_and_port_from_lb_key(vip_key).

typedef svc_monitor = SvcMonitor{
    port_name: string,          // Might name a switch or router port.
    src_ip: string
}

relation &LBVIPBackend(
    lbvip: Ref<LBVIP>,
    ip: string,
    port: bit<16>,
    addr_family: bit<32>,
    svc_monitor: Option<svc_monitor>)

function parse_ip_port_mapping(value: Option<string>): Option<svc_monitor> {
    var strs: Vec<string> = match (value) {
        Some{s} -> string_split(s, ":"),
        None -> return None
    };

    if (vec_len(strs) != 64'd2) {
        return None
    };

    match ((vec_nth(strs, 0), vec_nth(strs, 1))) {
        (Some{port_name}, Some{src_ip}) -> Some{SvcMonitor{port_name, src_ip}},
        _ -> None
    }
}

&LBVIPBackend(.lbvip = lbvip,
              .ip = ip,
              .port = port,
              .addr_family = addr_family,
              .svc_monitor = svc_monitor) :-
    LBVIP[lbvip],
    var backend = FlatMap(string_split(lbvip.backend_ips, ",")),
    Some{(var ip, var port, var addr_family)} = ip_address_and_port_from_lb_key(backend),
    (var svc_monitor) = parse_ip_port_mapping(map_get(lbvip.lb.ip_port_mappings, ip)).

function is_online(status: Set<string>): bool = {
    match (set_nth(status, 0)) {
        Some{s} -> s == "online",
        _ -> true
    }
}
function default_protocol(protocol: Set<string>): string = {
    match (set_nth(protocol, 0)) {
        Some{x} -> x,
        None -> "tcp"
    }
}
relation &LBVIPBackendStatus(
    port: bit<16>,
    ip: string,
    protocol: string,
    logical_port: string,
    up: bool)
&LBVIPBackendStatus(port, ip, protocol, logical_port, up) :-
    sm in sb.Service_Monitor(),
    var port = sm.port as bit<16>,
    var ip = sm.ip,
    var protocol = default_protocol(sm.protocol),
    var logical_port = sm.logical_port,
    var up = is_online(sm.status).
&LBVIPBackendStatus(port, ip, protocol, logical_port, true) :-
    LBVIPBackend[lbvipbackend],
    var port = lbvipbackend.port as bit<16>,
    var ip = lbvipbackend.ip,
    var protocol = default_protocol(lbvipbackend.lbvip.lb.protocol),
    Some{var svc_monitor} = lbvipbackend.svc_monitor,
    var logical_port = svc_monitor.port_name,
    not sb.Service_Monitor(.port = port as bit<64>,
                           .ip = ip,
                           .protocol = set_singleton(protocol),
                           .logical_port = logical_port).

/* SwitchPortDHCPv4Options: many-to-one relation between logical switches and DHCPv4 options */
relation SwitchPortDHCPv4Options(
    port: Ref<SwitchPort>,
    dhcpv4_options: Ref<nb.DHCP_Options>)

SwitchPortDHCPv4Options(port, options) :-
    port in &SwitchPort(.lsp = lsp),
    port.lsp.__type != "external",
    Some{var dhcpv4_uuid} = set_nth(lsp.dhcpv4_options, 0),
    options in &DHCP_OptionsRef[nb.DHCP_Options{._uuid = dhcpv4_uuid}].

/* SwitchPortDHCPv6Options: many-to-one relation between logical switches and DHCPv4 options */
relation SwitchPortDHCPv6Options(
    port: Ref<SwitchPort>,
    dhcpv6_options: Ref<nb.DHCP_Options>)

SwitchPortDHCPv6Options(port, options) :-
    port in &SwitchPort(.lsp = lsp),
    port.lsp.__type != "external",
    Some{var dhcpv6_uuid} = set_nth(lsp.dhcpv6_options, 0),
    options in &DHCP_OptionsRef[nb.DHCP_Options{._uuid = dhcpv6_uuid}].

/* SwitchQoS: many-to-one relation between logical switches and nb.QoS */
relation SwitchQoS(sw: Ref<Switch>, qos: Ref<nb.QoS>)

SwitchQoS(sw, qos) :-
    sw in &Switch(.ls = nb.Logical_Switch{.qos_rules = qos_rules}),
    var qos_rule = FlatMap(qos_rules),
    qos in &QoSRef[nb.QoS{._uuid = qos_rule}].

/* SwitchACL: many-to-many relation between logical switches and ACLs */
relation &SwitchACL(sw: Ref<Switch>,
                    acl: Ref<nb.ACL>)

&SwitchACL(.sw = sw, .acl = acl) :-
    LogicalSwitchACL(sw_uuid, acl_uuid),
    sw in &Switch(.ls = nb.Logical_Switch{._uuid = sw_uuid}),
    acl in &ACLRef[nb.ACL{._uuid = acl_uuid}].

relation SwitchPortUp(lsp: uuid, up: bool)

SwitchPortUp(lsp, up) :-
    nb.Logical_Switch_Port(._uuid = lsp, .name = lsp_name, .__type = __type),
    sb.Port_Binding(.logical_port = lsp_name, .chassis = chassis),
    var up =
        if (__type == "router") {
            true
        } else if (is_none(set_nth(chassis, 0))) {
            false
        } else {
            true
        }.

SwitchPortUp(lsp, up) :-
    nb.Logical_Switch_Port(._uuid = lsp, .name = lsp_name, .__type = __type),
    not sb.Port_Binding(.logical_port = lsp_name),
    var up = __type == "router".

relation SwitchPortHAChassisGroup0(lsp_uuid: uuid, ha_chassis_group_uuid: uuid)
SwitchPortHAChassisGroup0(lsp_uuid, hash128(ha_chassis_group_uuid_name)) :-
    lsp in nb.Logical_Switch_Port(._uuid = lsp_uuid),
    lsp.__type == "external",
    var ha_chassis_group_uuid = FlatMap(lsp.ha_chassis_group),
    ha_chassis_group in nb.HA_Chassis_Group(._uuid = ha_chassis_group_uuid),
    /* If the group is empty, then HA_Chassis_Group record will not be created in SB,
     * and so we should not create a reference to the group in Port_Binding table,
     * to avoid integrity violation. */
    not set_is_empty(ha_chassis_group.ha_chassis),
    LogicalSwitchPort(.lport = lsp_uuid, .lswitch = ls_uuid),
    var ha_chassis_group_uuid_name = ha_chassis_group_uuid_name(ls_uuid).
relation SwitchPortHAChassisGroup(lsp_uuid: uuid, ha_chassis_group_uuid: Option<uuid>)
SwitchPortHAChassisGroup(lsp_uuid, Some{ha_chassis_group_uuid}) :-
    SwitchPortHAChassisGroup0(lsp_uuid, ha_chassis_group_uuid).
SwitchPortHAChassisGroup(lsp_uuid, None) :-
    lsp in nb.Logical_Switch_Port(._uuid = lsp_uuid),
    not SwitchPortHAChassisGroup0(lsp_uuid, _).

/* SwitchPort relation collects all attributes of a logical switch port
 * - `peer` - peer router port, if any
 * - `static_dynamic_mac` - port has a "dynamic" address that contains a static MAC,
 *    e.g., "80:fa:5b:06:72:b7 dynamic"
 * - `static_dynamic_ipv4`, `static_dynamic_ipv6` - port has a "dynamic" address that contains a static IP,
 *    e.g., "dynamic 192.168.1.2"
 * - `needs_dynamic_ipv4address` - port requires a dynamically allocated IPv4 address
 * - `needs_dynamic_macaddress`  - port requires a dynamically allocated MAC address
 * - `needs_dynamic_tag`         - port requires a dynamically allocated tag
 * - `up`                        - true if the port is bound to a chassis or has type ""
 * - 'ha_chassis_group_uuid_name' - uuid_name of sb.HA_Chassis_Group, only for "external" ports
 */
relation &SwitchPort(
    lsp:                        nb.Logical_Switch_Port,
    json_name:                  string,
    sw:                         Ref<Switch>,
    peer:                       Option<Ref<RouterPort>>,
    static_addresses:           Vec<lport_addresses>,
    dynamic_address:            Option<lport_addresses>,
    static_dynamic_mac:         Option<eth_addr>,
    static_dynamic_ipv4:        Option<ovs_be32>,
    static_dynamic_ipv6:        Option<in6_addr>,
    ps_addresses:               Vec<lport_addresses>,
    ps_eth_addresses:           Vec<string>,
    parent_name:                Option<string>,
    needs_dynamic_ipv4address:  bool,
    needs_dynamic_macaddress:   bool,
    needs_dynamic_ipv6address:  bool,
    needs_dynamic_tag:          bool,
    up:                         bool,
    mcast_cfg:                  Ref<McastPortCfg>,
    ha_chassis_group_uuid:      Option<uuid>
)

&SwitchPort(.lsp                        = lsp,
            .json_name                  = json_string_escape(lsp.name),
            .sw                         = sw,
            .peer                       = peer,
            .static_addresses           = static_addresses,
            .dynamic_address            = dynamic_address,
            .static_dynamic_mac         = static_dynamic_mac,
            .static_dynamic_ipv4        = static_dynamic_ipv4,
            .static_dynamic_ipv6        = static_dynamic_ipv6,
            .ps_addresses               = ps_addresses,
            .ps_eth_addresses           = ps_eth_addresses,
            .parent_name                = parent_name,
            .needs_dynamic_ipv4address  = needs_dynamic_ipv4address,
            .needs_dynamic_macaddress   = needs_dynamic_macaddress,
            .needs_dynamic_ipv6address  = needs_dynamic_ipv6address,
            .needs_dynamic_tag          = needs_dynamic_tag,
            .up                         = up,
            .mcast_cfg                  = mcast_cfg,
            .ha_chassis_group_uuid      = ha_chassis_group_uuid) :-
    nb.Logical_Switch_Port[lsp],
    LogicalSwitchPort(lsp._uuid, lswitch_uuid),
    sw in &Switch(.ls = nb.Logical_Switch{._uuid = lswitch_uuid, .other_config = other_config},
                  .subnet = subnet,
                  .ipv6_prefix = ipv6_prefix),
    SwitchRouterPeerRef(lsp._uuid, peer),
    SwitchPortUp(lsp._uuid, up),
    mcast_cfg in &McastPortCfg(.port = lsp._uuid, .router_port = false),
    var static_addresses = {
        var static_addresses: Vec<lport_addresses> = vec_empty();
        for (addr in lsp.addresses) {
            if ((addr != "router") and (not is_dynamic_lsp_address(addr))) {
                match (extract_lsp_addresses(addr)) {
                    None -> (),
                    Some{lport_addr} -> vec_push(static_addresses, lport_addr)
                }
            } else ()
        };
        static_addresses
    },
    var ps_addresses = {
        var ps_addresses: Vec<lport_addresses> = vec_empty();
        for (addr in lsp.port_security) {
            match (extract_lsp_addresses(addr)) {
                None -> (),
                Some{lport_addr} -> vec_push(ps_addresses, lport_addr)
            }
        };
        ps_addresses
    },
    var ps_eth_addresses = {
        var ps_eth_addresses: Vec<string> = vec_empty();
        for (ps_addr in ps_addresses) {
            vec_push(ps_eth_addresses, ps_addr.ea_s)
        };
        ps_eth_addresses
    },
    var dynamic_address: Option<lport_addresses> = match (set_nth(lsp.dynamic_addresses, 0)) {
        None -> None,
        Some{lport_addr} -> extract_lsp_addresses(lport_addr)
    },
    (var static_dynamic_mac: Option<eth_addr>,
     var static_dynamic_ipv4: Option<ovs_be32>,
     var static_dynamic_ipv6: Option<in6_addr>,
     var has_dyn_lsp_addr: bool) = {
        var dynamic_address_request: Option<dynamic_address_request> = None;
        for (addr in lsp.addresses) {
            dynamic_address_request = parse_dynamic_address_request(addr);
            if (is_some(dynamic_address_request)) {
                break
            }
        };

        match (dynamic_address_request) {
            Some{DynamicAddressRequest{mac, ipv4, ipv6}} -> (mac, ipv4, ipv6, true),
            None -> (None, None, None, false)
        }
    },
    var needs_dynamic_ipv4address = has_dyn_lsp_addr and is_none(peer) and is_some(subnet) and
                                    is_none(static_dynamic_ipv4),
    var needs_dynamic_macaddress = has_dyn_lsp_addr and is_none(peer) and is_none(static_dynamic_mac) and
                                   (is_some(subnet) or is_some(ipv6_prefix) or
                                    map_get(other_config, "mac_only") == Some{"true"}),
    var needs_dynamic_ipv6address = has_dyn_lsp_addr and is_none(peer) and is_some(ipv6_prefix) and is_none(static_dynamic_ipv6),
    var parent_name: Option<string> = match (set_nth(lsp.parent_name, 0)) {
        None -> None,
        Some{pname} -> if (pname == "") { None } else { Some{pname} }
    },
    /* Port needs dynamic tag if it has a parent and its `tag_request` is 0. */
    var needs_dynamic_tag = is_some(parent_name) and
                            set_nth(lsp.tag_request, 0) == Some{0: integer},
    SwitchPortHAChassisGroup(.lsp_uuid = lsp._uuid,
                             .ha_chassis_group_uuid = ha_chassis_group_uuid).

/* Switch port port security addresses */
relation SwitchPortPSAddresses(port:     Ref<SwitchPort>,
                               ps_addrs: lport_addresses)

SwitchPortPSAddresses(port, ps_addrs) :-
    port in &SwitchPort(.ps_addresses = ps_addresses),
    var ps_addrs = FlatMap(ps_addresses).

/* All static addresses associated with a port parsed into
 * the lport_addresses data structure */
relation SwitchPortStaticAddresses(port: Ref<SwitchPort>,
                                   addrs:  lport_addresses)
SwitchPortStaticAddresses(port, addrs) :-
    port in &SwitchPort(.static_addresses = static_addresses),
    var addrs = FlatMap(static_addresses).

/* All static and dynamic addresses associated with a port parsed into
 * the lport_addresses data structure */
relation SwitchPortAddresses(port: Ref<SwitchPort>,
                             addrs:  lport_addresses)

SwitchPortAddresses(port, addrs) :- SwitchPortStaticAddresses(port, addrs).

SwitchPortAddresses(port, dynamic_address) :-
    SwitchPortNewDynamicAddress(port, Some{dynamic_address}).

/* "router" is a special Logical_Switch_Port address value that indicates that the Ethernet, IPv4, and IPv6
 * this port should be obtained from the connected logical router port, as specified by router-port in
 * options.
 *
 * The resulting addresses are used to populate the logical switch’s destination lookup, and also for the
 * logical switch to generate ARP and ND replies.
 *
 * If the connected logical router port is a distributed gateway port and the logical router has rules
 * specified in nat with external_mac, then those addresses are also used to populate the switch’s destination
 * lookup. */
SwitchPortAddresses(port, addrs) :-
    port in &SwitchPort(.lsp = lsp, .peer = Some{&rport}),
    Some{var addrs} = {
        var opt_addrs: Option<lport_addresses> = None;
        for (addr in lsp.addresses) {
            if (addr == "router") {
                opt_addrs = Some{rport.networks}
            } else ()
        };
        opt_addrs
    }.

/* All static and dynamic IPv4 addresses associated with a port */
relation SwitchPortIPv4Address(port: Ref<SwitchPort>,
                               ea_s:   string,
                               addr:   ipv4_netaddr)

SwitchPortIPv4Address(port, ea_s, addr) :-
    SwitchPortAddresses(port, LPortAddress{.ea_s = ea_s, .ipv4_addrs = addrs}),
    var addr = FlatMap(addrs).

/* All static and dynamic IPv6 addresses associated with a port */
relation SwitchPortIPv6Address(port:   Ref<SwitchPort>,
                               ea_s:   string,
                               addr:   ipv6_netaddr)

SwitchPortIPv6Address(port, ea_s, addr) :-
    SwitchPortAddresses(port, LPortAddress{.ea_s = ea_s, .ipv6_addrs = addrs}),
    var addr = FlatMap(addrs).

/* Service monitoring. */

/* MAC allocated for service monitor usage. Just one mac is allocated
 * for this purpose and ovn-controller's on each chassis will make use
 * of this mac when sending out the packets to monitor the services
 * defined in Service_Monitor Southbound table. Since these packets
 * all locally handled, having just one mac is good enough. */
function get_svc_monitor_mac(options: Map<string,string>, uuid: uuid)
    : eth_addr =
{
    var existing_mac: Option<eth_addr> = match (
        map_get(options, "svc_monitor_mac"))
    {
        Some{mac} -> scan_eth_addr(mac),
        None -> None
    };
    match (existing_mac) {
        Some{mac} -> mac,
        None -> eth_addr_from_uint64(pseudorandom_mac(uuid, 16'h5678))
    }
}
function put_svc_monitor_mac(options: Map<string,string>,
                             svc_monitor_mac: eth_addr) : Map<string,string> =
{
    map_insert_imm(options, "svc_monitor_mac", eth_addr2string(svc_monitor_mac))
}
relation SvcMonitorMac(mac: eth_addr)
SvcMonitorMac(get_svc_monitor_mac(options, uuid)) :-
    nb.NB_Global(._uuid = uuid, .options = options).
